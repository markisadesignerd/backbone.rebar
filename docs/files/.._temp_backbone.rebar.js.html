<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>..&#x2F;temp&#x2F;backbone.rebar.js - Backbone.Rebar</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="Backbone.Rebar"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.4.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Backbone.Rebar.Application.html">Backbone.Rebar.Application</a></li>
            
                <li><a href="..&#x2F;classes/Backbone.Rebar.CompositeView.html">Backbone.Rebar.CompositeView</a></li>
            
                <li><a href="..&#x2F;classes/Backbone.Rebar.DependencyRouter.html">Backbone.Rebar.DependencyRouter</a></li>
            
                <li><a href="..&#x2F;classes/Backbone.Rebar.Logger.html">Backbone.Rebar.Logger</a></li>
            
                <li><a href="..&#x2F;classes/Backbone.Rebar.Mediator.html">Backbone.Rebar.Mediator</a></li>
            
                <li><a href="..&#x2F;classes/Backbone.Rebar.PersistenceModel.html">Backbone.Rebar.PersistenceModel</a></li>
            
                <li><a href="..&#x2F;classes/Backbone.Rebar.View.html">Backbone.Rebar.View</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ..&#x2F;temp&#x2F;backbone.rebar.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(Backbone, _, $) {
    &#x27;use strict&#x27;;

    &#x2F;**
     * @namespace Backbone.Rebar
     *&#x2F;
    var Rebar = this.Rebar = Backbone.Rebar = {};

    &#x2F;&#x2F; =======================================================================
    &#x2F;&#x2F; === Helpers ===========================================================
    &#x2F;&#x2F; =======================================================================
    &#x2F;**
     * Extention functionality for the prototyped object that implements it.
     * @method extend
     * @param {Object} protoProps
     * @return {Object} child
     *&#x2F;
    var extend = function(protoProps) {
        var parent = this;
        var child = function() {
            parent.apply(this, arguments);
        };
        child.prototype = _.extend(parent.prototype, protoProps);
        return child;
    };
    &#x2F;&#x2F; =======================================================================
    &#x2F;&#x2F; === Application =======================================================
    &#x2F;&#x2F; =======================================================================

    &#x2F;**
     * The application shell provides a simple default architecture consisting of a model,
     * view and controller. The application is a singleton class in that there can only be one.
     * It extend &#x60;Backbone.Events&#x60; and you can see the [documentation](http:&#x2F;&#x2F;backbonejs.org&#x2F;#Events)
     * for more detailed information.
     * @class Application
     * @constructor
     * @extends Backbone.Events
     * @example
     *	var appConfig = {
     *		...
     *	};
     *	var app = new Backbone.Rebar.Application(appConfig);
     *	app.on(&quot;applicationStateChange&quot;,function(state){
     *		...
     *	});
     *	app.startup();
     *&#x2F;
    var Application = Rebar.Application = function(options) {
        &#x2F;&#x2F; singleton functionality
        if (Application.instance &amp;&amp; options &amp;&amp; !options._bypassSingleton) {
            return Application.instance;
        }
        if (options &amp;&amp; options.logLevel) {
            Logger.setLogLevel(options.logLevel);
        } else {
            Logger.setLogLevel(Logger.Levels.None);
        }
        Application.instance = this;
        this.options = options ? options : {};
        this.state = Application.States.Initialized;

        &#x2F;&#x2F; setup listener for app shutdown
        $(window).on(&#x27;beforeunload unload&#x27;, $.proxy(function(e) {
            this.state = Application.States.Shutdown;
        }, this));
    };

    &#x2F;**
     * Available states for the application used to describe the current state of the applicaiton.
     * @property States
     * @type Object
     * @for Application
     * @final
     *&#x2F;
    Application.States = {
        Default: 0,
        Initialized: 1,
        Faulted: 2,
        Started: 3,
        Shutdown: 4
    };

    Application.prototype = Object.create(Backbone.Events, {

        &#x2F;**
         * The current state value.
         * @property _state
         * @type Integer
         * @for Application
         * @private
         *&#x2F;
        _state: {
            value: Application.States.Default,
            writable: true
        },

        &#x2F;**
         * Getters and setters for the current state value.
         * @property state
         * @type Integer
         * @for Application
         *&#x2F;
        state: {
            get: function() {
                return this._state;
            },
            set: function(state) {
                if (this._state === state) {
                    return;
                }
                this._state = state;
                if (this._state === Application.States.Initialized) {
                    this.createModel();
                    this.createView();
                    this.createRouter();
                    this.initialize(this.options);
                }
                this.trigger(&#x27;applicationStateDidChange&#x27;, this.state);
            }
        },

        &#x2F;**
         * Initialization functionality for extended Applicaiton instances.
         * @method initialize
         * @for Application
         *&#x2F;
        initialize: {
            value: function(options) {},
            writable: true
        },

        &#x2F;**
         * Create a model instance for the Applicaiton instance.
         * @method createModel
         * @for Application
         *&#x2F;
        createModel: {
            value: function() {
                if (!this.model) {
                    this.model = new Backbone.Model();
                }
            },
            writable: true
        },

        &#x2F;**
         * Create a view instance for the Applicaiton instance.
         * @method createView
         * @for Application
         *&#x2F;
        createView: {
            value: function() {
                if (!this.view) {
                    this.view = new CompositeView({
                        el: $(&#x27;#application&#x27;)
                    });
                }
            },
            writable: true
        },

        &#x2F;**
         * Create a dependency router instance for the Applicaiton instance.
         * @method createRouter
         * @for Application
         *&#x2F;
        createRouter: {
            value: function() {
                if (!this.router) {
                    this.router = new DependencyRouter({
                        landing: this.options.landing ? this.options.landing : &#x27;&#x27;,
                        dispatcher: this
                    });
                    this.router.on(&#x27;routeDidChange&#x27;, function(route) {
                        this.trigger(&#x27;routeDidChange&#x27;, route);
                    }, this);
                }
            },
            writable: true
        },

        &#x2F;**
         * This method kicks off Backbone&#x27;s history managment as well as loads the bootstrap data
         * if a reference was passed through the contructors options argument.
         * @method startup
         * @for Application
         *&#x2F;
        startup: {
            value: function() {
                if (this.options.bootstrap) {
                    var delegate = this;
                    $.ajax({
                        cache: false,
                        dataType: &#x27;json&#x27;,
                        type: &#x27;GET&#x27;,
                        url: this.options.bootstrap,
                        success: function(response) {
                            if (!_.isEmpty(response)) {
                                delegate.model.set(&#x27;bootstrap&#x27;, response);
                                Backbone.history.start({
                                    pushState: false
                                });
                                delegate.state = Application.States.Started;
                            } else {
                                delegate.error = &#x27;Error: Bootstrap load error.&#x27;;
                                delegate.state = Application.States.Faulted;
                            }
                        },
                        error: function(error) {
                            delegate.error = error;
                            delegate.state = Application.States.Faulted;
                        }
                    });
                } else {
                    Backbone.history.start({
                        pushState: false
                    });
                    this.state = Application.States.Started;
                }
            }
        }
    });

    Application.extend = extend;
    &#x2F;&#x2F; =======================================================================
    &#x2F;&#x2F; === Persistence Model =================================================
    &#x2F;&#x2F; =======================================================================

    &#x2F;**
     * The &#x60;PeristenceModel&#x60; extends the basic [Backbone.Model](http:&#x2F;&#x2F;backbonejs.org&#x2F;#Model)
     * and overwrites its sync method to take advantage of local storage and persist data
     * across multiple pages within the same domain. The url property is used to grab data
     * from a specific object of the localStorage object. Use the &#x60;fetch&#x60; method to pull
     * whatever data already exists in localStorage and use the &#x60;save&#x60; method to store for
     * later use.
     * @class PersistenceModel
     * @extends Backbone.Model
     * @constructor
     * @example
     *	var model = new Backbone.Rebar.PersistenceModel({
     *		url:&quot;custom&quot;
     *	});
     *	model.fetch();
     *	model.set(&quot;foo&quot;,&quot;bar&quot;);
     *	model.save();
     *&#x2F;
    var PersistenceModel = Rebar.PersistenceModel = Backbone.Model.extend({

        &#x2F;**
         * Determains and returns a storage id based on the passed id in initialization
         * @method getStoargeId
         * @return {String} storage id for this persistence model
         * @private
         *&#x2F;
        getStoargeId: function() {
            var id = &#x27;pm&#x27;;
            if (this.urlRoot) {
                &#x2F;&#x2F; for right now lets just keep this simple
                &#x2F;&#x2F; @TODO: support ids with urlRoots
                id = id + &#x27;_&#x27; + this.url().split(&#x27;&#x2F;&#x27;)[0];
            }
            return id;
        },

        &#x2F;**
         * Overriden to make sure that we have a urlRoot on our persistence model
         * @method set
         * @param {Object} key
         * @param {Object} val
         * @param {Object} options
         *&#x2F;
        set: function(key, val, options) {
            if (key === &#x27;url&#x27;) {
                this.urlRoot = val;
            } else if (_.isObject(key) &amp;&amp; _.has(key, &#x27;url&#x27;) &amp;&amp; !_.isUndefined(key.url)) {
                this.urlRoot = key.url;
            }
            Backbone.Model.prototype.set.call(this, key, val, options);
        },

        &#x2F;**
         * Overridden to reroute the to a localStorage endpoint.
         * @method sync
         * @param {String} method
         * @param {PersistenceModel} model
         * @param {Object} options
         * @private
         *&#x2F;
        sync: function(method, model, options) {
            if (method === &#x27;read&#x27;) {
                this.pullLocalStore(model, options);
            } else if (method === &#x27;create&#x27;) {
                localStorage.setItem(model.getStoargeId(), JSON.stringify(_.omit(model.attributes, [&#x27;url&#x27;, &#x27;urlRoot&#x27;])));
            } else if (method === &#x27;update&#x27;) {
                this.pullLocalStore(model, options);
            } else if (method === &#x27;patch&#x27;) {
                throw &#x27;\&#x27;patch\&#x27; not implemented yet&#x27;;
            } else if (method === &#x27;delete&#x27;) {
                throw &#x27;\&#x27;delete\&#x27; not implemented yet&#x27;;
            }
        },

        &#x2F;**
         * Helper method pulls data based on urlRoot from local storage
         * @method pullLocalStore
         * @param {PersistenceModel} model
         * @param {Object} options
         *&#x2F;
        pullLocalStore: function(model, options) {
            if (localStorage) {
                var data = localStorage.getItem(model.getStoargeId());
                if (data !== null) {
                    var parsedData = JSON.parse(data);
                    model.set(parsedData);
                    if (options.success) {
                        options.success(model, parsedData, options);
                    }
                    model.trigger(&#x27;sync&#x27;, model, parsedData, options);
                }
            } else {
                var error = &#x27;Error: \&#x27;localStorage\&#x27; is not supported&#x27;;
                if (options.error) {
                    options.error(model, error, options);
                }
                model.trigger(&#x27;sync&#x27;, model, error, options);
            }
        }
    });
    &#x2F;&#x2F; =======================================================================
    &#x2F;&#x2F; === View ==============================================================
    &#x2F;&#x2F; =======================================================================

    &#x2F;**
     * Base class that extends [Backbone.View](http:&#x2F;&#x2F;backbonejs.org&#x2F;#View) and
     * provides boilerplate plate functionality for transitioning in and out, destroying
     * and rendering views.
     * @class View
     * @constructor
     * @extends Backbone.View
     * @example
     *	var view = new Backbone.Rebar.View({
     *		...
     *	});
     *	view.transitionIn({
     *		...
     *	});
     *	view.transitionOut({
     *		this.destroy();
     *	},this);
     *&#x2F;
    var View = Rebar.View = function(options) {
        Backbone.View.call(this, options);
        _.extend(this, _.pick(this.options, [&#x27;render&#x27;, &#x27;destroy&#x27;, &#x27;transitionIn&#x27;, &#x27;transitionOut&#x27;]));
    };

    View.prototype = Object.create(Backbone.View.prototype, {
        &#x2F;**
         * This method is a great helper method to call when the subclass view is about to be removed.
         * It recursively will call destroy on any subviews reference in the sub views array. It also handles
         * removing any event listeners that may have been added to the subViews array.
         * @method destroy
         *&#x2F;
        destroy: {
            value: function() {
                if (!this._isDestroyed) {
                    this._isDestroyed = true;
                    this.trigger(&#x27;viewDidDestroy&#x27;, this);
                    this.off();
                    this.$el.off();
                    this.remove();
                }
            },
            writable: true
        },

        &#x2F;**
         * For instances that are used in dependency routing the render method is called
         * and used directly after loading. For all other uses you must call render manually.
         * @method render
         * @param {Function} callback
         *&#x2F;
        render: {
            value: function(callback) {
                &#x2F;&#x2F; ...
            },
            writable: true
        },

        &#x2F;**
         * Transitions in the view. By default this method actually does nothing.
         * @method transitionIn
         * @param {Function} callback
         *&#x2F;
        transitionIn: {
            value: function(callback, context) {
                if (_.isFunction(callback)) {
                    callback.call(context ? context : this);
                }
            },
            writable: true
        },

        &#x2F;**
         * Transitions out the view. By default this method actually does nothing.
         * @method transitionOut
         * @param {Function} callback
         *&#x2F;
        transitionOut: {
            value: function(callback, context) {
                if (_.isFunction(callback)) {
                    callback.call(context ? context : this);
                }
            },
            writable: true
        }
    });

    View.extend = Backbone.View.extend;
    &#x2F;&#x2F; =======================================================================
    &#x2F;&#x2F; === Composite View ====================================================
    &#x2F;&#x2F; =======================================================================

    &#x2F;**
     * Most of the time Backbone views need to be able to contain other views. When you do this you run
     * into situations where you need to add the view then render and when you go to destroy the parent
     * view, you want to make sure you properly dispose of its children.
     * The composite view makes managing child parent relationships a bit easier by adding recursive destroy
     * functionality as well as making it possible to quickly add and remove child views.
     * @class CompositeView
     * @extends View
     * @constructor
     * @example
     *	var composite = new Backbone.Rebar.CompositeView({
     *		...
     *	});
     *	var view = new Backbone.Rebar.View({
     *		...
     *	});
     *	composite.addSubView(view);
     *&#x2F;
    var CompositeView = Rebar.CompositeView = function(options) {
        this.subViews = [];
        View.call(this, options);
        &#x2F;&#x2F;_.extend(this, _.pick(this.options, [&#x27;addSubView&#x27;, &#x27;removeSubView&#x27;, &#x27;removeAllSubViews&#x27;, &#x27;destroy&#x27;]));
    };

    CompositeView.prototype = Object.create(View.prototype, {

        &#x2F;**
         * Adds a sub view to a container BaseView
         * @method addSubView
         * @param {View} view
         *&#x2F;
        addSubView: {
            value: function(view) {
                &#x2F;&#x2F; add event listeners for view
                view.on(&#x27;viewDidDestroy&#x27;, function(view) {
                    this.removeSubView(view);
                }, this);
                &#x2F;&#x2F; add sub view
                this.subViews.push(view);
                &#x2F;&#x2F; render subview
                var delegate = this;
                view.render(function(el) {
                    var markup = el ? el : view.el;
                    delegate.$el.append(markup);
                });
                &#x2F;&#x2F; @TODO - possibly trigger view has been added
            },
            writable: true
        },

        &#x2F;**
         * Adds an array of sub views to a container BaseView
         * @method addSubViews
         * @param {Array} views Array of subviews
         *&#x2F;
        addSubViews: {
            value: function(views) {
                _.each(views, function(view) {
                    this.addSubView(view);
                }, this);
            },
            writable: true
        },

        &#x2F;**
         * Removes a sub view from the container view
         * @method removeSubView
         * @param {Object} view A base view or a cid of the sub view
         *&#x2F;
        removeSubView: {
            value: function(view) {
                &#x2F;&#x2F; assuming that what was passed was not an actual view and in fact was a cid
                if (!view.cid) {
                    view = _.where(this.subViews, {
                        cid: view
                    })[0];
                }
                this.destroySubView(view);
                this.subViews = _.reject(this.subViews, function(subView) {
                    return subView.cid === view.cid;
                });
            },
            writable: true
        },

        &#x2F;**
         * Removes all sub views from view
         * @method removeAllSubViews
         *&#x2F;
        removeAllSubViews: {
            value: function() {
                _.each(this.subViews, function(view) {
                    this.removeSubView(view);
                }, this);

            },
            writable: true
        },

        &#x2F;**
         * This method is a great helper method to call when the subclass view is about to be removed.
         * It recursively will call destroy on any subviews reference in the sub views array. It also handles
         * removing any event listeners that may have been added to the subViews array.
         * @method destroy
         *&#x2F;
        destroy: {
            value: function() {
                &#x2F;&#x2F; recursively destroy sub views
                if (this.subViews.length &gt; 0) {
                    _.each(this.subViews, function(view) {
                        this.destroySubView(view);
                    }, this);
                }
                this.subViews = [];
                View.prototype.destroy.call(this);
            },
            writable: true
        },

        &#x2F;**
         * Checks to see if the passed view has destroy functionality and then if it does not
         * calls the prototype destroy functionality and passes the reference
         * @method destroySubView
         * @param {View} view
         *&#x2F;
        destroySubView: {
            value: function(view) {
                if (_.isFunction(view.destroy)) {
                    view.destroy(true);
                } else {
                    if (!_.isUndefined(view.cid)) {
                        View.prototype.destroy.call(view);
                    }
                }
            },
            writable: true
        }
    });

    CompositeView.extend = View.extend;
    &#x2F;&#x2F; =======================================================================
    &#x2F;&#x2F; === Mediator ==========================================================
    &#x2F;&#x2F; =======================================================================

    &#x2F;**
     * Simple implementation of the mediator pattern for use with Backbone.Views.
     * event architecture
     * @class Mediator
     * @constructor
     * @uses extend
     * @example
     *	var mediator = new Mediator({
     *		events:{
     *			&quot;appwide1&quot;:{
     *				dispatcher:app
     *				callback:&quot;method&quot;
     *			}
     *		},
     *		initialize:function(options){
     *			...
     *		},
     *		method:function(e){
     *			...
     *		},
     *		handle:function(eventName,module){
     *			...
     *		}
     *	});
     *	mediator.addView(view,&quot;event1 event2&quot;);
     *	view.trigger(&quot;something&quot;,view);
     *	mediator.removeView(view);
     *&#x2F;
    var Mediator = Rebar.Mediator = function(options) {
        if (options) {
            this.options = options;
            _.extend(this, _.pick(this.options, [&#x27;initialize&#x27;, &#x27;handle&#x27;, &#x27;view&#x27;]));
            if (this.options.events) {
                this.processEvents(this.options.events);
            }
            if (this.view &amp;&amp; this.options.viewEvents) {
                this.processViewEvents(this.options.viewEvents);
            }
        }
        this._views = [];
        this.initialize(options);
    };

    Mediator.prototype = Object.create(Backbone.Events, {

        &#x2F;**
         * Stores reference to all views added to the mediator.
         * @property _views
         * @type Array
         * @for Mediator
         * @private
         *&#x2F;
        _views: {
            value: undefined,
            writable: true,
            configurable: false
        },

        &#x2F;**
         * Reference to a single view who we&#x27;ll be mediating for.
         * @property view
         * @type Backbone.View
         * @for Mediator
         *&#x2F;
        view: {
            value: undefined,
            writable: true,
            configurable: false
        },

        &#x2F;**
         * Called for any modules that extend the &#x60;Mediator&#x60; prototype.
         * @method initialize
         * @for Mediator
         *&#x2F;
        initialize: {
            value: function(options) {},
            writable: true
        },

        &#x2F;**
         * Adds module as one that the mediator should be listening for events.
         * @method addView
         * @for Mediator
         * @param {Backbone.View} view
         * @param {String} eventNames
         *&#x2F;
        addView: {
            value: function(view, eventNames) {
                var events;
                if (eventNames) {
                    events = eventNames.split(&#x27; &#x27;);
                } else {
                    events = [&#x27;all&#x27;];
                }
                _.each(events, function(eventName) {
                    view.on(eventName, function(options) {
                        this.handle(eventName, view, options);
                    }, this);
                }, this);
                this._views.push(view);
            },
            writable: true
        },

        &#x2F;**
         * Removes module from one that the mediator should be listening for.
         * @method removeView
         * @for Mediator
         * @param {Backbone.View} view
         *&#x2F;
        removeView: {
            value: function(view) {
                &#x2F;&#x2F; @TODO: remove all events that the view has with this handler
                view.off(null, this.handle, this);
                this._views = _.reject(this._views, function(v) {
                    if (v.cid === view.cid) {
                        return true;
                    }
                    return false;
                }, this);
            },
            writable: true
        },

        &#x2F;**
         * Returns boolean for whether the mediator contains a view or not.
         * @method hasView
         * @for Mediator
         * @param {Backbone.View} view
         *&#x2F;
        hasView: {
            value: function(view) {
                return _.where(this._views, {
                    cid: view.cid
                })[0];
            },
            writable: true
        },

        &#x2F;**
         * Returns a view that has the same value&#x2F;key pairs provided
         * @method getView
         * @for Mediator
         * @param {Object} attribute Key&#x2F;Value pair to use with an UnderscoreJS _.with look up
         * @example
         *	...
         *	mediator.getView({name:&quot;foo&quot;});
         *&#x2F;
        getView: {
            value: function(attribute) {
                return _.filter(this._views, function(view) {
                    var key = _.keys(attribute)[0];
                    var value = _.values(attribute)[0];
                    if (view[key] &amp;&amp; view[key] === value) {
                        return true;
                    } else if (view.options &amp;&amp; view.options[key] &amp;&amp; view.options[key] === value) {
                        return true;
                    }
                    return false;
                })[0];
            },
            writable: true
        },

        &#x2F;**
         * Returns a view that has the same **user defined** name provided
         * @method getViewByName
         * @for Mediator
         * @param {String} name User defined view name
         * @example
         *	...
         *	mediator.getView({name:&quot;foo&quot;});
         *&#x2F;
        getViewByName: {
            value: function(name) {
                var view = this.getView({
                    name: name
                });
                if (_.isUndefined(view)) {
                    console.warn(&#x27;Property \&#x27;name\&#x27; was not found on any views.&#x27;);
                }
                return view;
            },
            writable: true
        },

        &#x2F;**
         * destroys a mediator and removes all listeners.
         * @method destroy
         * @for Mediator
         *&#x2F;
        destroy: {
            value: function() {
                _.each(this._views, function(view) {
                    this.removeView(view);
                }, this);
            },
            writable: true
        },

        &#x2F;**
         * Handler method that is called when one of the module the mediator is listening
         * for is fired. Should be overriden in &#x60;Mediator&#x60; instances.
         * @method handle
         * @for Mediator
         * @param {Object} eventName
         * @param {Object} module
         *&#x2F;
        handle: {
            value: function(eventName, view) {},
            writable: true
        },

        &#x2F;**
         * Runs through all of the events that the mediator should be listening for.
         * @method processEvents
         * @for Mediator
         * @param {Object} events
         * @private
         *&#x2F;
        processEvents: {
            value: function(events) {
                for (var item in events) {
                    var eventObj = events[item];
                    if (_.isObject(eventObj)) {
                        this.assignCallbackToDispatcher(item, eventObj.callback, eventObj.dispatcher);
                    } else {
                        this.assignCallbackToDispatcher(item, eventObj, this.options.dispatcher);
                    }
                }
            }
        },

        processViewEvents: {
            value: function(events) {
                var eventsArr = events.split(&quot; &quot;);
                _.each(eventsArr, function(event, index) {
                    this.view.on(event.toString(), function(options) {
                        this.handle(event, this.view, options);
                    }, this);
                }, this);
            }
        },

        &#x2F;**
         * Assigns a callback to the passed dispatcher for the event to be fired.
         * @method assignCallbackToDispatcher
         * @for Mediator
         * @param {String} eventName
         * @param {String} callbackName
         * @param {Object} dispatcher
         * @private
         *&#x2F;
        assignCallbackToDispatcher: {
            value: function(eventName, callbackName, dispatcher) {
                if (this[callbackName]) {
                    dispatcher.on(eventName, this[callbackName], this);
                } else if (this.options[callbackName]) {
                    dispatcher.on(eventName, this.options[callbackName], this);
                } else {
                    console.error(&#x27;Error: No method \&#x27;&#x27; + callbackName + &#x27;\&#x27; found on mediator&#x27;);
                }
            }
        }
    });

    Mediator.extend = extend;
    &#x2F;&#x2F; =======================================================================
    &#x2F;&#x2F; === Controller ========================================================
    &#x2F;&#x2F; =======================================================================

    &#x2F;**
     * The application shell provides a simple default architecture consisting of a model,
     * view and controller. The application is a singleton class in that there can only be one.
     * It extend &#x60;Backbone.Events&#x60; and you can see the [documentation](http:&#x2F;&#x2F;backbonejs.org&#x2F;#Events)
     * for more detailed information.
     * @class Application
     * @constructor
     * @extends Backbone.Events
     * @example
     *&#x2F;
    var Controller = Rebar.Controller = function() {};
    Controller.prototype = Object.create(Backbone.Events, {});
    &#x2F;&#x2F; =======================================================================
    &#x2F;&#x2F; === Dependency Router =================================================
    &#x2F;&#x2F; =======================================================================

    &#x2F;**
     * Handles all pre and post routing functionality. This is the default router when you initialize
     * an &#x60;Application&#x60; instance. Once initialized any time the browser&#x27;s anchor location changes this
     * class notifies the rest of the application of the new directory, file, view and anchor to use.
     * To use simply listen to the application&#x27;s &#x60;routeDidChange&#x60; or the router&#x27;s &#x60;routeDidChange&#x60; event firing
     * and then implement the AMD loader that makes the most sense (for your project) to use.
     * @class DependencyRouter
     * @extends Backbone.Router
     * @constructor
     * @example
     *	&#x2F;&#x2F; requirejs example
     *	router.on(&quot;routeDidChange&quot;, function(route){
     *		var mReq = require([resource], function(a) {
     *			var Constructor = a[view];
     *			var v = new Constructor({
     *				routeData: data
     *			});
     *			delegate.addSubView(v);
     *		}, function(e) {
     *			console.log(&quot;Error: &quot; + e);
     *		});
     *	});
     *&#x2F;
    var DependencyRouter = Rebar.DependencyRouter = Backbone.Router.extend({

        &#x2F;**
         * Default landing for no hash. Where the browser will be routed to when landing
         * on the root url of the applicaiton.
         * @property landing
         * @type {String}
         * @default &quot;&quot;
         *&#x2F;
        landing: &#x27;&#x27;,

        &#x2F;**
         * Define only the route hash here because we&#x27;ll be using dependency routing
         * for the rest of the functionality.
         * @property routes
         * @type {Object} route key value pairs
         * @default { &quot;&quot;: &quot;handleNoHash&quot;, &quot;*splat&quot;: &quot;handleAll&quot; }
         * @private
         *&#x2F;
        routes: {
            &#x27;&#x27;: &#x27;handleNoHash&#x27;,
            &#x27;*splat&#x27;: &#x27;handleAll&#x27;
        },

        &#x2F;**
         * This object is empty by default, but routes added here, either manually,
         * or through the two methods, setStaticRoute and setStaticRoutes, will bypass
         * the handleAll and handleNoHash methods referenced in the routes object.
         * @property staticRoutes
         * @type {Object} static route key value pairs
         * @private
         *&#x2F;
        staticRoutes: {},

        &#x2F;**
         * Router init functionality
         * @method initialize
         * @param {Object} options
         * @private
         *&#x2F;
        initialize: function(options) {
            if (!_.isUndefined(options)) {
                if (!_.isUndefined(options.landing)) {
                    this.landing = options.landing;
                }
            }
        },

        &#x2F;**
         * Reroute the page to the page referenced as landing
         * @method handleNoHash
         * @private
         *&#x2F;
        handleNoHash: function() {
            this.handleAll(this.landing + Backbone.history.location.search);
        },

        &#x2F;**
         * Handles every route that doesnt match any of the previous matches
         * @method handleAll
         * @private
         *&#x2F;
        handleAll: function(route) {

            &#x2F;&#x2F; reference the current url from backbone
            var routeString = _.isUndefined(route) ? Backbone.history.getFragment() : route;

            &#x2F;&#x2F; check to make sure we dont have any static routes that were added
            for (var sRoute in this.staticRoutes) {
                if (sRoute === routeString) {
                    this.staticRoutes[sRoute]();
                    return;
                }
            }

            var pRoute = this.parseRoute(routeString);

            &#x2F;&#x2F; now that we&#x27;re sure that the current route is not one of the static routes set
            &#x2F;&#x2F; then we&#x27;ll move forward with the dependency routing functionality
            this.trigger(&#x27;routeDidChange&#x27;, pRoute);
            this.pRoute = pRoute;

        },

        &#x2F;**
         * Parses a passed route string and determains directory, file, view and data
         * @method parseRoute
         * @param {String} route The current Backbone.history fragment
         * @private
         *&#x2F;
        parseRoute: function(route) {

            var hash = route.split(&#x27;&#x2F;&#x27;);
            var directory;
            var file;

            &#x2F;&#x2F; define view and data
            var splitView = hash[hash.length - 1].split(&#x27;?&#x27;);

            &#x2F;&#x2F; figure out view and anchor
            var viewParts = splitView[0].split(&#x27;#&#x27;);
            var view = viewParts[0];
            var anchor = viewParts[1];

            var data = this.parseRouteData(splitView[1]);

            &#x2F;&#x2F; if only two parts are passed then we should assume that there is no directory and the two parts
            &#x2F;&#x2F; are the file reference and the view reference is the view to instantiate
            if (hash.length === 2) {
                file = hash[0];
            }

            &#x2F;&#x2F; this is the default behavior, 3 parts, directory, file and view
            if (hash.length === 3) {
                directory = hash[0];
                file = hash[1];
            }

            &#x2F;&#x2F; here we&#x27;re going to take everything before the last two parts of the has and concider them
            &#x2F;&#x2F; to be directories
            if (hash.length &gt; 3) {
                var dirLength = hash.length - 2;
                directory = &#x27;&#x27;;
                for (var i = 0; i &lt; dirLength; i++) {
                    directory += hash[i] + (i &lt; dirLength - 1 ? &#x27;&#x2F;&#x27; : &#x27;&#x27;);
                }
                file = hash[hash.length - 2];
            }

            return {
                directory: directory,
                file: file,
                view: view !== &#x27;&#x27; ? view : undefined,
                data: data,
                anchor: anchor
            };
        },

        &#x2F;**
         * Parse the query string provides and returns key value pair object
         * @method parseRouteData
         * @param {String} query
         * @private
         *&#x2F;
        parseRouteData: function(query) {
            if (_.isUndefined(query)) {
                return undefined;
            }
            var vars = query.split(&#x27;&amp;&#x27;);
            var data = {};
            _.each(vars, function(v) {
                var pair = v.split(&#x27;=&#x27;);
                data[pair[0]] = pair[1];
            });
            return data;
        },

        &#x2F;**
         * Takes a passed route object and determains a file location
         * @method getFileLocation
         * @param {Object} route Object formed in parseRoute method
         * @private
         *&#x2F;
        getFileLocation: function(route) {
            if (_.isUndefined(route.directory) || route.directory === &#x27;&#x27;) {
                if (_.isUndefined(route.file) || route.file === &#x27;&#x27;) {
                    return &#x27;&#x27;;
                }
                return route.file;
            }
            return route.directory + &#x27;&#x2F;&#x27; + route.file;
        },

        &#x2F;**
         * Adds the name and method to the staticRoutes object as a key&#x2F;value pair
         * @method setStaticRoute
         * @param {String} name
         * @param {Function} method
         *&#x2F;
        setStaticRoute: function(name, method) {
            this.staticRoutes[name] = method;
        },

        &#x2F;**
         * Takes key value pairs from an object and sets them to the staticRoutes
         * object on the router
         * @method setStaticRoutes
         * @param {Object} routes
         *&#x2F;
        setStaticRoutes: function(routes) {
            for (var route in routes) {
                this.staticRoutes[route] = routes[route];
            }
        }
    });
    &#x2F;&#x2F; =======================================================================
    &#x2F;&#x2F; === Logger ============================================================
    &#x2F;&#x2F; =======================================================================

    &#x2F;**
     * Logger
     * @class Logger
     *&#x2F;
    var Logger = Rebar.Logger = (function() {

        var root = this;
        var _console = typeof(console) !== undefined;
        var _logLevel = 0;

        function log(msg) {
            if (_console &amp;&amp; _logLevel &gt;= Logger.Levels.Info) {
                root.console.log(msg);
            }
        }

        function warn(msg) {
            if (_console &amp;&amp; _logLevel &gt;= Logger.Levels.Info) {
                root.console.warn(msg);
            }
        }

        function error(msg) {
            if (_console &amp;&amp; _logLevel &gt;= Logger.Levels.Error) {
                root.console.error(msg);
            }
        }

        function setLogLevel(logLevel) {
            _logLevel = logLevel;
            return _logLevel;
        }

        return {
            log: log,
            warn: warn,
            error: error,
            setLogLevel: setLogLevel,
            Levels: {
                None: 0,
                Error: 10,
                Info: 20,
                Verbose: 30
            }
        };
    }).call(this);
}).call(this, Backbone, _, $);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
