<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>..&#x2F;temp&#x2F;backbone.rebar.js - Backbone.Rebar</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="Backbone.Rebar"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.4.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Backbone.Rebar.Application.html">Backbone.Rebar.Application</a></li>
            
                <li><a href="..&#x2F;classes/Backbone.Rebar.CompositeView.html">Backbone.Rebar.CompositeView</a></li>
            
                <li><a href="..&#x2F;classes/Backbone.Rebar.DependencyRouter.html">Backbone.Rebar.DependencyRouter</a></li>
            
                <li><a href="..&#x2F;classes/Backbone.Rebar.PersistenceModel.html">Backbone.Rebar.PersistenceModel</a></li>
            
                <li><a href="..&#x2F;classes/Backbone.Rebar.Services.html">Backbone.Rebar.Services</a></li>
            
                <li><a href="..&#x2F;classes/Backbone.Rebar.View.html">Backbone.Rebar.View</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ..&#x2F;temp&#x2F;backbone.rebar.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * Backbone.Rebar v0.4.0
 * Adding a little bit more reinforcement to an already spectacular framework.
 * https:&#x2F;&#x2F;github.com&#x2F;mcgaryes&#x2F;rebar
 *&#x2F;
(function(Backbone, _, $) {

    &quot;use strict&quot;;

    &#x2F;**
     * @namespace Backbone.Rebar
     *&#x2F;
    var Rebar = Backbone.Rebar = {};

    &#x2F;&#x2F; =======================================================================
    &#x2F;&#x2F; === Helpers ===========================================================
    &#x2F;&#x2F; =======================================================================

    &#x2F;**
     * Extention functionality for the prototyped object that implements it.
     * @method extend
     * @param {Object} protoProps
     * @return {Object} child
     *&#x2F;
    var extend = function(protoProps) {
        var parent = this;
        var child = function() {
            parent.apply(this, arguments);
        };
        child.prototype = _.extend(parent.prototype, protoProps);
        return child;
    };

    &#x2F;&#x2F; =======================================================================
    &#x2F;&#x2F; === Services ==========================================================
    &#x2F;&#x2F; =======================================================================

    &#x2F;**
     * Static class with boilerplate functionality for jquery ajax requests
     * @class Services
     * @static
     *&#x2F;
    var Services = Rebar.Services = {

        &#x2F;**
         * jQuery wrapper for ajax() calls
         * @method request
         * @param {Object} options
         * @param {Object} context
         * @private
         * @for Services
         *&#x2F;
        request: function(type, options, context) {

            &#x2F;&#x2F; options
            var opts = this.parseOptions(options);
            var id = opts.id;
            var error = opts.error;
            var success = opts.success;
            var data = opts.data;
            var delegate = this;
            var url = opts.url;

            &#x2F;&#x2F; create ajax object
            var o = {};

            &#x2F;&#x2F; set the url passed
            o.url = opts.url ? opts.url : (opts.id ? this.getServiceEndpointById(id) : undefined);

            &#x2F;&#x2F; set the data passed
            if (!_.isUndefined(data)) {
                o.data = data;
            }

            &#x2F;&#x2F; set the success funx
            o.success = function(response) {
                if (!_.isEmpty(response)) {
                    delegate.handleSuccess(context, success, response);
                } else {
                    delegate.handleError(context);
                }
            };

            &#x2F;&#x2F; set the error funx
            o.error = function(e) {
                delegate.handleError(context, error, e);
            };

            o.cache = false;
            o.dataType = &#x27;json&#x27;;
            o.type = type;

            &#x2F;&#x2F; call ajax
            $.ajax(o);

        },

        &#x2F;**
         * Parses the incoming options object to the http method and returns
         * a useable options object for the request
         * @method parseOptions
         * @param {Object} options
         * @private
         * @for Services
         *&#x2F;
        parseOptions: function(options) {
            return {
                id: options.id ? options.id : undefined,
                error: options.error ? options.error : function() {},
                success: options.success ? options.success : function() {},
                data: options.data ? options.data : undefined,
                url: options.url ? options.url : undefined
            };
        },

        &#x2F;**
         * Processes the error object returned by the http request
         * @method parseError
         * @param {Object} error
         * @private
         * @for Services
         *&#x2F;
        parseError: function(error) {
            var temp = {};
            if (_.isUndefined(error) || _.isEmpty(error) || _.isNull(error)) {
                temp.code = 204;
                temp.message = &quot;No Content&quot;;
            } else {
                temp.code = error.status;
                temp.message = error.statusText;
            }
            temp.originalError = error;
            return temp;
        },

        &#x2F;**
         * jquery success handler
         * @method handleSuccess
         * @param {Object} context
         * @param {Function} callback
         * @param {Object} response
         * @private
         * @for Services
         *&#x2F;
        handleSuccess: function(context, callback, response) {
            callback.call(context, response);
        },

        &#x2F;**
         * jquery ajax error handler
         * @method handleError
         * @param {Object} context
         * @param {Function} callback
         * @param {Object} response
         * @private
         * @for Services
         *&#x2F;
        handleError: function(context, callback, response) {
            callback.call(context, this.parseError(response));
        },

        &#x2F;**
         * GET request
         * @method get
         * @param {Object} options
         * @param {Object} context
         * @for Services
         *&#x2F;
        get: function(options, context) {
            this.request(&quot;GET&quot;, options, context);
        },

        &#x2F;**
         * POST request
         * @method post
         * @param {Object} options
         * @param {Object} context
         * @for Services
         *&#x2F;
        post: function(options, context) {
            this.request(&quot;POST&quot;, options, context);
        },

        &#x2F;**
         * PUT request
         * @method put
         * @param {Object} options
         * @param {Object} context
         * @for Services
         *&#x2F;
        put: function(options, context) {
            this.request(&quot;PUT&quot;, options, context);
        },

        &#x2F;**
         * DELETE request
         * @method delete
         * @param {Object} options
         * @param {Object} context
         * @for Services
         *&#x2F;
        delete: function(options, context) {
            this.request(&quot;DELETE&quot;, options, context);
        }
    };

    &#x2F;&#x2F; =======================================================================
    &#x2F;&#x2F; === Application =======================================================
    &#x2F;&#x2F; =======================================================================

    &#x2F;**
     * The application shell provides a simple default architecture consisting of a model,
     * view and controller. The application is a singleton class in that there can only be one.
     * It extend &#x60;Backbone.Events&#x60; and you can see the [documentation](http:&#x2F;&#x2F;backbonejs.org&#x2F;#Events) 
     * for more detailed information.
     * @class Application
     * @constructor
     * @extends Backbone.Events
     * @example
     *	var appConfig = {
     *		...	
     *	};
     *	var app = new Backbone.Rebar.Application(appConfig);
     *	app.on(&quot;applicationStateChange&quot;,function(state){
     *		...
     *	});
     *	app.startup();
     *&#x2F;
    var Application = Rebar.Application = function(options) {
        &#x2F;&#x2F; singleton functionality
        if (Application.instance &amp;&amp; !options._bypassSingleton) {
            return Application.instance;
        }
        if (options &amp;&amp; options.logLevel) {
            Application.logLevel = options.logLevel;
        } else {
            Application.logLevel = Application.LogLevel.None;
        }
        Application.instance = this;
        this.options = options;
        this.state = Application.States.Initialized;
    };

    &#x2F;**
     * Available loglevels used in various logging tasks throughout the applicaiton.
     * @property LogLevel
     * @type Object
     * @for Application
     * @final
     *&#x2F;
    Application.LogLevel = {
        None: 0,
        Error: 10,
        Info: 20,
        Verbose: 30
    };

    &#x2F;**
     * Available states for the application used to describe the current state of the applicaiton.
     * @property States
     * @type Object
     * @for Application
     * @final
     *&#x2F;
    Application.States = {
        Default: 0,
        Initialized: 1,
        Started: 3,
        Faulted: 2
    };

    Application.prototype = Object.create(Backbone.Events, {

        &#x2F;**
         * The current state value.
         * @property _state
         * @type Integer
         * @for Application
         * @private
         *&#x2F;
        _state: {
            value: Application.States.Default,
            writable: true
        },

        &#x2F;**
         * Getters and setters for the current state value.
         * @property state
         * @type Integer
         * @for Application
         *&#x2F;
        state: {
            get: function() {
                return this._state;
            },
            set: function(state) {
                if (this._state === state) {
                    return;
                }
                this._state = state;
                if (this._state === Application.States.Initialized) {
                    this.createModel();
                    this.createView();
                    this.createRouter();
                    this.initialize(this.options);
                }
                this.trigger(&quot;applicationStateDidChange&quot;, this.state);
            }
        },

        &#x2F;**
         * Reference to the services object.
         * @property services
         * @type Services
         * @for Application
         *&#x2F;
        services: {
            value: Services,
            writable: false
        },

        &#x2F;**
         * Initialization functionality for extended Applicaiton instances.
         * @method initialize
         * @for Application
         *&#x2F;
        initialize: {
            value: function(options) {},
            writable: true
        },

        &#x2F;**
         * Create a model instance for the Applicaiton instance.
         * @method createModel
         * @for Application
         *&#x2F;
        createModel: {
            value: function() {
                if (!this.model) {
                    this.model = new Backbone.Model();
                }
            },
            writable: true
        },

        &#x2F;**
         * Create a view instance for the Applicaiton instance.
         * @method createView
         * @for Application
         *&#x2F;
        createView: {
            value: function() {
                if (!this.view) {
                    this.view = new CompositeView({
                        el: $(&quot;#application&quot;)
                    });
                }
            },
            writable: true
        },

        &#x2F;**
         * Create a dependency router instance for the Applicaiton instance.
         * @method createRouter
         * @for Application
         *&#x2F;
        createRouter: {
            value: function() {
                if (!this.router) {
                    this.router = new DependencyRouter({
                        landing: this.options.landing ? this.options.landing : &quot;&quot;,
                        dispatcher: this
                    });
                    this.router.on(&quot;routeDidChange&quot;, function(route) {
                        this.trigger(&quot;routeDidChange&quot;, route);
                    }, this);
                }
            },
            writable: true
        },

        &#x2F;**
         * This method kicks off Backbone&#x27;s history managment as well as loads the bootstrap data
         * if a reference was passed through the contructors options argument.
         * @method startup
         * @for Application
         *&#x2F;
        startup: {
            value: function() {
                if (this.options.bootstrap) {
                    this.services.get({
                        url: this.options.bootstrap,
                        success: function(response) {
                            this.model.set(&quot;bootstrap&quot;, response);
                            Backbone.history.start({
                                pushState: false
                            });
                            this.state = Application.States.Started;
                        },
                        error: function(error) {
                            this.error = error;
                            this.state = Application.States.Faulted;
                        }
                    }, this);
                } else {
                    Backbone.history.start({
                        pushState: false
                    });
                    this.state = Application.States.Started;
                }
            }
        }
    });

    Application.extend = extend;

    &#x2F;&#x2F; =======================================================================
    &#x2F;&#x2F; === Persistence Model =================================================
    &#x2F;&#x2F; =======================================================================

    &#x2F;**
     * The &#x60;PeristenceModel&#x60; extends the basic [Backbone.Model](http:&#x2F;&#x2F;backbonejs.org&#x2F;#Model)
     * and overwrites its sync method to take advantage of local storage and persist data
     * across multiple pages within the same domain. The url property is used to grab data
     * from a specific object of the localStorage object. Use the &#x60;fetch&#x60; method to pull
     * whatever data already exists in localStorage and use the &#x60;save&#x60; method to store for
     * later use.
     * @class PersistenceModel
     * @extends Backbone.Model
     * @constructor
     * @example
     *	var model = new Backbone.Rebar.PersistenceModel({
     *		url:&quot;custom&quot;
     *	});
     *	model.fetch();
     *	model.set(&quot;foo&quot;,&quot;bar&quot;);
     *	model.save();
     *&#x2F;
    var PersistenceModel = Rebar.PersistenceModel = Backbone.Model.extend({

        &#x2F;**
         * Determains and returns a storage id based on the passed id in initialization
         * @method getStoargeId
         * @return {String} storage id for this persistence model
         * @private
         *&#x2F;
        getStoargeId: function() {
            var id = &quot;pm&quot;;
            if (this.urlRoot) {
                &#x2F;&#x2F; for right now lets just keep this simple
                &#x2F;&#x2F; @TODO: support ids with urlRoots
                id = id + &quot;_&quot; + this.url().split(&quot;&#x2F;&quot;)[0];
            }
            return id;
        },

        &#x2F;**
         * Overriden to make sure that we have a urlRoot on our persistence model
         * @method set
         * @param {Object} key
         * @param {Object} val
         * @param {Object} options
         *&#x2F;
        set: function(key, val, options) {
            console.log(key);
            if (key === &quot;url&quot;) {
                this.urlRoot = val;
            } else if (_.isObject(key) &amp;&amp; _.has(key, &quot;url&quot;) &amp;&amp; !_.isUndefined(key.url)) {
                this.urlRoot = key.url;
            }
            Backbone.Model.prototype.set.call(this, key, val, options);
        },

        &#x2F;**
         * Overridden to reroute the to a localStorage endpoint.
         * @method sync
         * @param {String} method
         * @param {PersistenceModel} model
         * @param {Object} options
         * @private
         *&#x2F;
        sync: function(method, model, options) {
            if (method === &quot;read&quot;) {
                this.pullLocalStore(model, options);
            } else if (method === &quot;create&quot;) {
                localStorage.setItem(model.getStoargeId(), JSON.stringify(_.omit(model.attributes, [&quot;url&quot;, &quot;urlRoot&quot;])));
            } else if (method === &quot;update&quot;) {
                this.pullLocalStore(model, options);
            } else if (method === &quot;patch&quot;) {
                throw &quot;&#x27;patch&#x27; not implemented yet&quot;;
            } else if (method === &quot;delete&quot;) {
                throw &quot;&#x27;delete&#x27; not implemented yet&quot;;
            }
        },

        &#x2F;**
         * Helper method pulls data based on urlRoot from local storage
         * @method pullLocalStore
         * @param {PersistenceModel} model
         * @param {Object} options
         *&#x2F;
        pullLocalStore: function(model, options) {
            if (localStorage) {
                var data = localStorage.getItem(model.getStoargeId());
                if (data !== null) {
                    console.log(data);
                    var parsedData = JSON.parse(data);
                    model.set(parsedData);
                    if (options.success) {
                        options.success(model, parsedData, options);
                    }
                    model.trigger(&#x27;sync&#x27;, model, parsedData, options);
                }
            } else {
                var error = &quot;Error: &#x27;localStorage&#x27; is not supported&quot;;
                if (options.error) {
                    options.error(model, error, options);
                }
                model.trigger(&#x27;sync&#x27;, model, error, options);
            }
        }
    });

    &#x2F;&#x2F; =======================================================================
    &#x2F;&#x2F; === View ==============================================================
    &#x2F;&#x2F; =======================================================================

    &#x2F;**
     * Base class that extends [Backbone.View](http:&#x2F;&#x2F;backbonejs.org&#x2F;#View) and
     * provides boilerplate plate functionality for transitioning in and out, destroying
     * and rendering views.
     * @class View
     * @constructor
     * @extends Backbone.View
     * @example
     *	var view = new Backbone.Rebar.View({
     *		...
     *	});
     *	view.transitionIn({
     *		...
     *	});
     *	view.transitionOut({
     *		this.destroy();
     *	},this);
     *&#x2F;
    var View = Rebar.View = Backbone.View.extend({

        &#x2F;**
         * @method initialize
         *&#x2F;
        initialize: function() {
            _.extend(this, _.pick(this.options, [&quot;render&quot;, &quot;destroy&quot;, &quot;transitionIn&quot;, &quot;transitionOut&quot;]));
        },

        &#x2F;**
         * This method is a great helper method to call when the subclass view is about to be removed.
         * It recursively will call destroy on any subviews reference in the sub views array. It also handles
         * removing any event listeners that may have been added to the subViews array.
         * @method destroy
         *&#x2F;
        destroy: function() {
            if (!this._isDestroyed) {
                this._isDestroyed = true;
                this.trigger(&quot;viewDidDestroy&quot;, this);
                this.off();
                this.$el.off();
                this.remove();
            }
        },

        &#x2F;**
         * For instances that are used in dependency routing the render method is called
         * and used directly after loading. For all other uses you must call render manually.
         * @method render
         * @param {Function} callback
         *&#x2F;
        render: function(callback) {},

        &#x2F;**
         * Transitions in the view. By default this method actually does nothing.
         * @method transitionIn
         * @param {Function} callback
         *&#x2F;
        transitionIn: function(callback, context) {
            if (_.isFunction(callback)) {
                callback.call(context ? context : this);
            }
        },

        &#x2F;**
         * Transitions out the view. By default this method actually does nothing.
         * @method transitionOut
         * @param {Function} callback
         *&#x2F;
        transitionOut: function(callback, context) {
            if (_.isFunction(callback)) {
                callback.call(context ? context : this);
            }
        }
    });

    &#x2F;&#x2F; =======================================================================
    &#x2F;&#x2F; === Composite View ====================================================
    &#x2F;&#x2F; =======================================================================

    &#x2F;**
     * Most of the time Backbone views need to be able to contain other views. When you do this you run
     * into situations where you need to add the view then render and when you go to destroy the parent 
     * view, you want to make sure you properly dispose of its children. 
     * The composite view makes managing child parent relationships a bit easier by adding recursive destroy
     * functionality as well as making it possible to quickly add and remove child views.
     * @class CompositeView
     * @extends View
     * @constructor
     * @example
     *	var composite = new Backbone.Rebar.CompositeView({
     *		...
     *	});
     *	var view = new Backbone.Rebar.View({
     *		...
     *	});
     *	composite.addSubView(view);
     *&#x2F;
    var CompositeView = Rebar.CompositeView = Backbone.Rebar.View.extend({

        &#x2F;**
         * Creates an empty array where subview references can be push for later use.
         * @method initialize
         *&#x2F;
        initialize: function() {
            this.subViews = [];
            _.extend(this, _.pick(this.options, [&quot;addSubView&quot;, &quot;removeSubView&quot;, &quot;removeAllSubViews&quot;, &quot;destroy&quot;]));
            View.prototype.initialize.call(this);
        },

        &#x2F;**
         * Adds a sub view to a container BaseView
         * @method addSubView
         * @param {View} view
         *&#x2F;
        addSubView: function(view) {
            &#x2F;&#x2F; add event listeners for view
            view.on(&quot;viewDidDestroy&quot;, function(view) {
                this.removeSubView(view);
            }, this);
            &#x2F;&#x2F; add sub view 
            this.subViews.push(view);
            &#x2F;&#x2F; render subview
            var delegate = this;
            view.render(function(el) {
                var markup = el ? el : view.el;
                delegate.$el.append(markup);
            });
            &#x2F;&#x2F; @TODO - possibly trigger view has been added
        },

        &#x2F;**
         * Adds an array of sub views to a container BaseView
         * @method addSubViews
         * @param {Array} views Array of subviews
         *&#x2F;
        addSubViews: function(views) {
            _.each(views, function(view) {
                this.addSubView(view);
            }, this);
        },

        &#x2F;**
         * Removes a sub view from the container view
         * @method removeSubView
         * @param {Object} view A base view or a cid of the sub view
         *&#x2F;
        removeSubView: function(view) {
            &#x2F;&#x2F; assuming that what was passed was not an actual view and in fact was a cid
            if (!view.cid) {
                view = _.where(this.subViews, {
                    cid: view
                })[0];
            }
            this.destroySubView(view);
            this.subViews = _.reject(this.subViews, function(subView) {
                return subView.cid === view.cid;
            });
        },

        &#x2F;**
         * Removes all sub views from view
         * @method removeAllSubViews
         *&#x2F;
        removeAllSubViews: function() {
            _.each(this.subViews, function(view) {
                this.removeSubView(view);
            }, this);
        },

        &#x2F;**
         * This method is a great helper method to call when the subclass view is about to be removed.
         * It recursively will call destroy on any subviews reference in the sub views array. It also handles
         * removing any event listeners that may have been added to the subViews array.
         * @method destroy
         *&#x2F;
        destroy: function() {

            &#x2F;&#x2F; recursively destroy sub views
            if (this.subViews.length &gt; 0) {
                _.each(this.subViews, function(view) {
                    this.destroySubView(view);
                }, this);
            }

            this.subViews = [];

            View.prototype.destroy.call(this);
        },

        &#x2F;**
         * Checks to see if the passed view has destroy functionality and then if it does not
         * calls the prototype destroy functionality and passes the reference
         * @method destroySubView
         * @param {View} view
         *&#x2F;
        destroySubView: function(view) {
            if (_.isFunction(view.destroy)) {
                view.destroy(true);
            } else {
                if (!_.isUndefined(view.cid)) {
                    View.prototype.destroy.call(view);
                }
            }
        }
    });

    &#x2F;&#x2F; =======================================================================
    &#x2F;&#x2F; === Dependency Router =================================================
    &#x2F;&#x2F; =======================================================================

    &#x2F;**
     * Handles all pre and post routing functionality. This is the default router when you initialize
     * an &#x60;Application&#x60; instance. Once initialized any time the browser&#x27;s anchor location changes this
     * class notifies the rest of the application of the new directory, file, view and anchor to use.
     * To use simply listen to the application&#x27;s &#x60;routeDidChange&#x60; or the router&#x27;s &#x60;routeDidChange&#x60; event firing
     * and then implement the AMD loader that makes the most sense (for your project) to use.
     * @class DependencyRouter
     * @extends Backbone.Router
     * @constructor
     * @example
     *	&#x2F;&#x2F; requirejs example
     *	router.on(&quot;routeDidChange&quot;, function(route){
     *		var mReq = require([resource], function(a) {
     *			var Constructor = a[view];
     *			var v = new Constructor({
     *				routeData: data
     *			});
     *			delegate.addSubView(v);
     *		}, function(e) {
     *			console.log(&quot;Error: &quot; + e);
     *		});
     *	});
     *&#x2F;
    var DependencyRouter = Rebar.DependencyRouter = Backbone.Router.extend({

        &#x2F;**
         * Default landing for no hash. Where the browser will be routed to when landing
         * on the root url of the applicaiton.
         * @property landing
         * @type {String}
         * @default &quot;&quot;
         *&#x2F;
        landing: &quot;&quot;,

        &#x2F;**
         * Define only the route hash here because we&#x27;ll be using dependency routing
         * for the rest of the functionality.
         * @property routes
         * @type {Object} route key value pairs
         * @default { &quot;&quot;: &quot;handleNoHash&quot;, &quot;*splat&quot;: &quot;handleAll&quot; }
         * @private
         *&#x2F;
        routes: {
            &quot;&quot;: &quot;handleNoHash&quot;,
            &quot;*splat&quot;: &quot;handleAll&quot;
        },

        &#x2F;**
         * This object is empty by default, but routes added here, either manually,
         * or through the two methods, setStaticRoute and setStaticRoutes, will bypass
         * the handleAll and handleNoHash methods referenced in the routes object.
         * @property staticRoutes
         * @type {Object} static route key value pairs
         * @private
         *&#x2F;
        staticRoutes: {},

        &#x2F;**
         * Router init functionality
         * @method initialize
         * @param {Object} options
         * @private
         *&#x2F;
        initialize: function(options) {
            if (!_.isUndefined(options)) {
                if (!_.isUndefined(options.landing)) {
                    this.landing = options.landing;
                }
            }
        },

        &#x2F;**
         * Reroute the page to the page referenced as landing
         * @method handleNoHash
         * @private
         *&#x2F;
        handleNoHash: function() {
            this.handleAll(this.landing + Backbone.history.location.search);
        },

        &#x2F;**
         * Handles every route that doesnt match any of the previous matches
         * @method handleAll
         * @private
         *&#x2F;
        handleAll: function(route) {

            &#x2F;&#x2F; reference the current url from backbone
            var routeString = _.isUndefined(route) ? Backbone.history.getFragment() : route;

            &#x2F;&#x2F; check to make sure we dont have any static routes that were added
            for (var sRoute in this.staticRoutes) {
                if (sRoute === routeString) {
                    this.staticRoutes[sRoute]();
                    return;
                }
            }

            var pRoute = this.parseRoute(routeString);
            var router = this;
            var directory = this.getFileLocation(pRoute);

            &#x2F;&#x2F; now that we&#x27;re sure that the current route is not one of the static routes set
            &#x2F;&#x2F; then we&#x27;ll move forward with the dependency routing functionality
            this.trigger(&quot;routeDidChange&quot;, pRoute);
            this.pRoute = pRoute;

        },

        &#x2F;**
         * Parses a passed route string and determains directory, file, view and data
         * @method parseRoute
         * @param {String} route The current Backbone.history fragment
         * @private
         *&#x2F;
        parseRoute: function(route) {

            var hash = route.split(&quot;&#x2F;&quot;);
            var directory;
            var file;

            &#x2F;&#x2F; define view and data
            var splitView = hash[hash.length - 1].split(&quot;?&quot;);

            &#x2F;&#x2F; figure out view and anchor
            var viewParts = splitView[0].split(&quot;#&quot;);
            var view = viewParts[0];
            var anchor = viewParts[1];

            var data = this.parseRouteData(splitView[1]);

            &#x2F;&#x2F; if only two parts are passed then we should assume that there is no directory and the two parts
            &#x2F;&#x2F; are the file reference and the view reference is the view to instantiate
            if (hash.length === 2) {
                file = hash[0];
            }

            &#x2F;&#x2F; this is the default behavior, 3 parts, directory, file and view
            if (hash.length === 3) {
                directory = hash[0];
                file = hash[1];
            }

            &#x2F;&#x2F; here we&#x27;re going to take everything before the last two parts of the has and concider them
            &#x2F;&#x2F; to be directories
            if (hash.length &gt; 3) {
                var dirLength = hash.length - 2;
                directory = &quot;&quot;;
                for (var i = 0; i &lt; dirLength; i++) {
                    directory += hash[i] + (i &lt; dirLength - 1 ? &quot;&#x2F;&quot; : &quot;&quot;);
                }
                file = hash[hash.length - 2];
            }

            return {
                directory: directory,
                file: file,
                view: view !== &quot;&quot; ? view : undefined,
                data: data,
                anchor: anchor
            };
        },

        &#x2F;**
         * Parse the query string provides and returns key value pair object
         * @method parseRouteData
         * @param {String} query
         * @private
         *&#x2F;
        parseRouteData: function(query) {
            if (_.isUndefined(query)) {
                return undefined;
            }
            var vars = query.split(&#x27;&amp;&#x27;);
            var data = {};
            _.each(vars, function(v) {
                var pair = v.split(&quot;=&quot;);
                data[pair[0]] = pair[1];
            });
            return data;
        },

        &#x2F;**
         * Takes a passed route object and determains a file location
         * @method getFileLocation
         * @param {Object} route Object formed in parseRoute method
         * @private
         *&#x2F;
        getFileLocation: function(route) {
            if (_.isUndefined(route.directory) || route.directory === &quot;&quot;) {
                if (_.isUndefined(route.file) || route.file === &quot;&quot;) {
                    return &quot;&quot;;
                }
                return route.file;
            }
            return route.directory + &quot;&#x2F;&quot; + route.file;
        },

        &#x2F;**
         * Adds the name and method to the staticRoutes object as a key&#x2F;value pair
         * @method setStaticRoute
         * @param {String} name
         * @param {Function} method
         *&#x2F;
        setStaticRoute: function(name, method) {
            this.staticRoutes[name] = method;
        },

        &#x2F;**
         * Takes key value pairs from an object and sets them to the staticRoutes
         * object on the router
         * @method setStaticRoutes
         * @param {Object} routes
         *&#x2F;
        setStaticRoutes: function(routes) {
            for (var route in routes) {
                this.staticRoutes[route] = routes[route];
            }
        }
    });

}).call(this, Backbone, _, $);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
